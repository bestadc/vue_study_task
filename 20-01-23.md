question:讲讲你对vue diff算法的理解

answer：
我理解的diff算法就是vue在数据发生变化的时候，dom更新时，为了减少不必要的dom更新而做的一个优化处理，就是实现最小颗粒的的dom更新，在dom发生变化时，diff算法会先判断当前组件的新旧虚拟dom树是否有子节点，分四种情况：
1、如果都没有，则只是文本的替换；
2、如果newVnode有子节点，oldVnode没有子节点，则会清空oldVnode的文本，再为其新增子节点；
3、如果newVnode没有子节点，oldVnode有子节点，则会删除oldVnode的所有子节点；
4、如果newVnode个oldVnode都有子节点的时候，则会进行其children的对比；
在开始下一步之前，会定义几个变量，oldStartVnode，oldEndVnode,oldStartIdx,oldEndIdx,newStartVnode，newEndVnode,newStartIdx,newEndIdx,
分别表示旧节点的开始节点，结束节点，以及其下标和新的开始节点、结束节点和其下标；
如果oldStartVnode或则oldEndVnode为undefinde，则将其值赋值为下一个/上一个节点的vnode，其对应的下标也自增/自减
（1）、如果newStartVnode和oldStartVnod满足sameVnode，则进行patchVnode，其值改为下一节点的值，对应的下标自增1；
（2）、如果newEndVnode和oldEndVnode满足sameVnode，则进行patchVnode，其值改为上一节点的值，对应的下标自减1；
（3）、如果newStartVnode和oldEndVnode满足sameVnode，则将其进行patchVnode，并将oldEndVnode移动到oldStartVnode的前面，对应的下标自增/自减 1；
（4）、如果newEndVnode和oldStartVnode满足sameVnode，则将其进行patchVnode，并将oldStartVnode移动到oldEndVnode的后面，对应的下标自减/自增 1；
（5）、如果前面四种都不满足，则循环旧节点，将其key作为键，其下标index作为值存入map集合中保存在函数作用域下的变量内，如果newStartVnode的key在集合中不存在，则创建一个新的节点并插入到旧节点的对应位置中；如果存在，则判断其是否满足sameVnode，满足就将其进行patchVnode，并移动对应节点到相应的位置；
如果不满足，则创建新节点并插入到oldVnode中的相应位置中；
（6）、最后，如果newStartIdx>newEndIdx，说明新节点是少于旧节点的，则批量删除旧节点
如果oldStartIdx>oldEndIdx，说明新节点是多于旧节点的，则批量新增dom节点， 并插入到oldVnode中